<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1" />
  <meta name="viewport" content="width=device-width">
  <link rel="canonical" href="http://knexjs.org" />
  <link rel="icon" href="docs/images/favicon.ico" />
  <title>Knex.js</title>
  <style>
    body {
      font-size: 14px;
      line-height: 22px;
      background: #f4f4f4;
      color: #000;
      font-family: Helvetica Neue, Helvetica, Arial;
    }
    .interface {
      font-family: "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, sans-serif !important;
    }
    div#sidebar {
      background: #fff;
      position: fixed;
      top: 0; left: 0; bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #bbb;
      box-shadow: 0 0 20px #ccc; -webkit-box-shadow: 0 0 20px #ccc; -moz-box-shadow: 0 0 20px #ccc;
    }
    a.toc_title, a.toc_title:visited {
      display: block;
      color: black;
      font-weight: bold;
      margin-top: 15px;
    }
      a.toc_title:hover {
        text-decoration: underline;
      }
      #sidebar .version {
        font-size: 10px;
        font-weight: normal;
      }
    ul.toc_section {
      font-size: 11px;
      line-height: 14px;
      margin: 5px 0 0 0;
      padding-left: 0px;
      list-style-type: none;
      font-family: Lucida Grande;
    }
      .toc_section li {
        cursor: pointer;
        margin: 0 0 3px 0;
      }
        .toc_section li a {
          text-decoration: none;
          color: black;
        }
          .toc_section li a:hover {
            text-decoration: underline;
          }
    div.container {
      width: 550px;
      margin: 40px 0 50px 260px;
    }
    img#logo {
      width: 450px;
    }
    div.warning {
      margin-top: 15px;
      font: bold 11px Arial;
      color: #770000;
    }
    p {
      margin: 20px 0;
      width: 550px;
    }
    a, a:visited {
      color: #444;
    }
    a:active, a:hover {
      color: #000;
    }
    h1, h2, h3, h4, h5, h6 {
      padding-top: 20px;
    }
      h2 {
        font-size: 20px;
      }
    b.header {
      font-size: 16px;
      line-height: 30px;
    }
    span.alias {
      font-size: 14px;
      font-style: italic;
      margin-left: 20px;
    }
    table, tr, td {
      margin: 0; padding: 0;
    }
      td {
        padding: 2px 12px 2px 0;
      }
      table .rule {
        height: 1px;
        background: #ccc;
        margin: 5px 0;
      }
    ul {
      list-style-type: circle;
      padding: 0 0 0 20px;
    }
      li {
        width: 500px;
        margin-bottom: 10px;
      }
      code, pre, tt {
        font-family: Monaco, Consolas, "Lucida Console", monospace;
        font-size: 12px;
        line-height: 18px;
        font-style: normal;
      }
        tt {
          padding: 0px 3px;
          background: #fff;
          border: 1px solid #ddd;
          zoom: 1;
        }
        code {
          margin-left: 20px;
        }
        pre {
          font-size: 12px;
          padding: 2px 0 2px 15px;
          border-left: 5px solid #bbb;
          margin: 0px 0 30px;
        }
    @media only screen and (-webkit-min-device-pixel-ratio: 1.5) and (max-width: 640px),
          only screen and (-o-min-device-pixel-ratio: 3/2) and (max-width: 640px),
          only screen and (min-device-pixel-ratio: 1.5) and (max-width: 640px) {
      img {
        max-width: 100%;
      }
      div#sidebar {
        -webkit-overflow-scrolling: initial;
        position: relative;
        width: 90%;
        height: 120px;
        left: 0;
        top: -7px;
        padding: 10px 0 10px 30px;
        border: 0;
      }
      img#logo {
        width: auto;
        height: auto;
      }
      div.container {
        margin: 0;
        width: 100%;
      }
      p, div.container ul {
        max-width: 98%;
        overflow-x: scroll;
      }
      pre {
        overflow: scroll;
      }
    }
  </style>
</head>
<body>

  <div id="sidebar" class="interface">

    <a class="toc_title" href="#">
      Knex.js <span class="version">(0.1.0)</span>
    </a>
    <ul class="toc_section">
      <li>&raquo; <a href="https://github.com/tgriesser/knex">GitHub Repository</a></li>
      <li>&raquo; <a href="http://knexjs.org/docs/knex.html">Annotated Source</a></li>
    </ul>

    <a class="toc_title" href="#installation">
      Installation
    </a>

    <a class="toc_title" href="#Initialize">
      Initialize
    </a>

    <a class="toc_title" href="#Builder">
      Builder
    </a>
    <ul class="toc_section">
      <li>– <a href="#Builder-main"><b>constructor</b></a></li>
      <li>– <a href="#Builder-select">select</a></li>
      <li>– <a href="#Builder-from">from</a></li>
      <li>– <a href="#Builder-where">where <b>16 methods</b></a></li>
      <li>– <a href="#Builder-distinct">distinct</a></li>
      <li>– <a href="#Builder-join">join</a></li>
      <li>– <a href="#Builder-groupBy">groupBy</a></li>
      <li>– <a href="#Builder-orderBy">orderBy</a></li>
      <li>– <a href="#Builder-having">having</a></li>
      <li>– <a href="#Builder-offset">offset</a></li>
      <li>– <a href="#Builder-limit">limit</a></li>
      <li>– <a href="#Builder-insert">insert *</a></li>
      <li>– <a href="#Builder-update">update *</a></li>
      <li>– <a href="#Builder-del">del / delete *</a></li>
      <li>– <a href="#Builder-count">count</a></li>
      <li>– <a href="#Builder-min">min</a></li>
      <li>– <a href="#Builder-max">max</a></li>
      <li>– <a href="#Builder-sum">sum</a></li>
      <li>– <a href="#Builder-increment">increment</a></li>
      <li>– <a href="#Builder-decrement">decrement</a></li>
      <li>– <a href="#Builder-truncate">truncate *</a></li>
      <li>– <a href="#Builder-debug">debug</a></li>
      <li><b><a href="#Schema-Building">Interface:</a></b></li>
      <li>– <a href="#Builder-then">then</a></li>
      <li>– <a href="#Builder-exec">exec</a></li>
    </ul>

    <a class="toc_title" href="#Transaction">
      Transaction
    </a>

    <a class="toc_title" href="#Schema">
      Schema
    </a>
    <ul class="toc_section">
      <li>– <a href="#Schema-createTable">createTable</a></li>
      <li>– <a href="#Schema-renameTable">renameTable</a></li>
      <li>– <a href="#Schema-dropTable">dropTable</a></li>
      <li>– <a href="#Schema-hasTable">hasTable</a></li>
      <li>– <a href="#Schema-dropTableIfExists">dropTableIfExists</a></li>
      <li>– <a href="#Schema-table">table</a></li>
      <li><b><a href="#Schema-Building">Schema Building:</a></b></li>
      <li>– <a href="#Schema-dropColumn">dropColumn</a></li>
      <li>– <a href="#Schema-dropColumns">dropColumns</a></li>
      <li>– <a href="#Schema-increments">increments</a></li>
      <li>– <a href="#Schema-integer">integer</a></li>
      <li>– <a href="#Schema-text">text</a></li>
      <li>– <a href="#Schema-string">string</a></li>
      <li>– <a href="#Schema-float">float</a></li>
      <li>– <a href="#Schema-decimal">decimal</a></li>
      <li>– <a href="#Schema-boolean">boolean</a></li>
      <li>– <a href="#Schema-date">date</a></li>
      <li>– <a href="#Schema-dateTime">dateTime</a></li>
      <li>– <a href="#Schema-time">time</a></li>
      <li>– <a href="#Schema-timestamp">timestamp</a></li>
      <li>– <a href="#Schema-binary">binary</a></li>
      <li>– <a href="#Schema-enum">enum / enu</a></li>
      <li><a href="#Chainable"><b>Chainable:</b></li>
      <li>– <a href="#Chainable-defaultTo">defaultTo</a></li>
      <li>– <a href="#Chainable-unsigned">unsigned</a></li>
      <li>– <a href="#Chainable-nullable">nullable</a></li>
    </ul>


    <a class="toc_title" href="#faq">
      F.A.Q.
    </a>

    <a class="toc_title" href="#changelog">
      Change Log
    </a>

  </div>

  <div class="container">

    <p>
      <img id="logo" src="docs/images/knex.png" alt="Knex.js">
    </p>

    <p>
      <b>Knex.js</b> is a multi-dialect sql builder, designed to be flexible, portable, and fun to use.
      It features both traditional node style <a href="#Builder-exec">callbacks</a> as well 
      as a <a href="#Builder-then">promise</a> interface for cleaner async flow control, full featured 
      query and schema builders, transaction support, connection pooling and node.js adapters for 
      postgres, mysql, and sqlite3 - standardizing the responses between the three.
    </p>

    <p>
      The project is <a href="http://github.com/tgriesser/knex">hosted on GitHub</a>,
      and the <a href="docs/knex.html">annotated source code</a> is available,
      and has a comprehensive <a href="https://travis-ci.org/tgriesser/knex">test suite</a>.
    </p>

    <a href="https://travis-ci.org/tgriesser/knex">
      <img src="https://travis-ci.org/tgriesser/knex.png?branch=master" alt="Travis Badge">
    </a>

    <p>
      Knex is available for use under the <a href="http://github.com/tgriesser/knex/blob/master/LICENSE">MIT software license</a>.
    </p>

    <p>
      You can report bugs and discuss features on the
      <a href="http://github.com/tgriesser/knex/issues">GitHub issues page</a>,
      add pages to the <a href="https://github.com/tgriesser/knex/wiki">wiki</a>
      or send tweets to <a href="http://twitter.com/tgriesser">@tgriesser</a>.
    </p>

    <p>
      Special thanks to <a href="https://twitter.com/taylorotwell">Taylor Otwell</a> and his work 
      on the <a href="http://four.laravel.com/docs/queries">Laravel Query Builder</a>,
      from which much of the code and syntax is derived.
    </p>

    <h2 id="installation">
      Installation
    </h2>

    <p>
      All dependencies are specified in <tt>package.json</tt> file but include <tt>underscore.js</tt>,
      <tt>when.js</tt>, and the <tt>generic-pool</tt> library. You then need to install 
      either <tt>mysql</tt>, <tt>pg</tt>, or <tt>sqlite3</tt> from <tt>npm</tt> if you wish 
      to use one of these databases with node.js, or create your own client 
      adapter and specify it in <a href="#Initialize">Knex.Initialize</a>.
    </p>

    <pre>
$ npm install knex

# Then add one of the following:
$ npm install mysql
$ npm install pg
$ npm install sqlite3
</pre>

    <h2 id="Initialize">Knex.Initialize</h2>

    <p>
      <tt>Knex.Initialize</tt> is the initializing function that must be called prior to using
      Knex, accepting a few parameters. The <tt>client</tt> parameter is required 
      and determines which client adapter will be used with the library.
    </p>

<pre>
Knex.Initialize({
  client: 'mysql',
  connection: {
    host     : '127.0.0.1',
    user     : 'root',
    password : '',
    database : 'myapp_test',
    charset  : 'utf8'
  }
});
</pre>

  <p>
    It is also possible to use Knex with multiple database connection instances if you'd like, 
    by creating named instances. To do this, pass the name of the connection as the first 
    parameter into <tt>Knex.Initialize</tt> and it will return that instance, which may
    also be referenced by name under <tt>Knex.Instances</tt>.
  </p>

<pre>
var SqliteDB = Knex.Initialize('sqlitedb', {
  client: 'sqlite',
  connection: {
    database : './testdb'
  }
});

var MySql2 = Knex.Initialize('mysql2', {
  client: 'mysql',
  connection: { ... }
});

// Knex.Instances['mysql2'] === MySql2;
// Knex.Instances['sqlitedb'] === SqliteDB;

MySql2('accounts')
  .select()
  .then(function(resp) {
    // ...
  });

SqliteDB('users')
  .insert({email: 'test@email.com'})
  .exec(function(err, resp) {
    // ...
  });
</pre>

    <h2 id="Builder">Knex.Builder</h2>

    <p>
      The <tt>Knex.Builder</tt> is the interface used for building and executing standard SQL queries,
      such as <tt>select</tt>, <tt>insert</tt>, <tt>update</tt>, <tt>delete</tt>. The query is run
      by specifying a <a href="#Builder-table">tableName</a>, adding additional query parameters, and 
      executing the query with one of the public interface methods.
    </p>

    <p id="Builder-main">
      <b class="header">Knex</b><code>Knex(tableName)...</code>
      <br />
      The <b>Knex</b> query builder starts off by specifying a <b>tableName</b> you wish to query against,
      which returns a chainable interface, similar to a jQuery chain. You can then call any additional 
      query builder methods needed to construct the query, eventually calling either 
      <a href="#Builder-then">then</a> or <a href="#Builder-exec">exec</a>, to execute the query with a
      promise or a callback, respectively.
    </p>

    <p id="Builder-select">
      <b class="header">select</b><code>.select([*columns])</code>
      <br />
      Creates a <tt>select</tt> query, taking an optional array of <b>columns</b> for the query, eventually
      defaulting to <tt>*</tt> if none are specified when the query is built. The response of a select call will
      return with the 
    </p>

<pre>
  // select "title", "author", "year" from "books"
  Knex('books').select('title', 'author', 'year');
  
  // select * from "books"
  Knex('books').select();
</pre>


    <p id="Builder-from">
      <b class="header">from</b><code>.from([tableName])</code>
      <br />
      Specifies the table used in the current query, replacing the current table name if
      one has already been specified. This is typically used in the sub-queries performed
      in the ______ methods.
    </p>

    <p id="Builder-where">
      <b class="header">where</b><code>.where(~dynamic~)</code>
      <br />
      One of the most flexible and imporant pieces of Knex, is the <tt>where</tt> clause generation.
      <br />
      There are several different types of arguments where may take, and several helper methods to simplify
      or, and, whereIn, etc.
    </p>

<pre>
// Basic Uses:

.where('id', '=', 1).where('used_count', '>', 10);

.where('title', 'like', 'test').orWhere('title', 'like', 'fail');

.where({email: 'test@example.com'}).and('other_key', 2)

</pre>

<h3>Additional Where Methods:</h3>

<ul class="small">
  <li><b>andWhere(column, operator, value)</b> &mdash; alias to standard "where" clause.</li>
  <li><b>orWhere(column, operator, value)</b> &mdash; adds an <tt>or where</tt> clause.</li>
  <li><b>whereExists(callback)</b> &mdash; </li>
  <li><b>whereNotExists(callback)</b> &mdash; </li>
</ul>

<h3>Advanced Where Methods:</h3>

<ul class="small">
  <li><b>andWhere(column, operator, value)</b> &mdash; Alias to default where.</li>
  <li><b>orWhere(column, operator, value)</b> &mdash; adds an <tt>or where</tt> clause.</li>
  <li><b>whereExists(callback)</b> &mdash; </li>
  <li><b>whereNotExists(callback)</b> &mdash; </li>
</ul>

    <p id="Builder-distinct">
      <b class="header">distinct</b><code>.distinct()</code>
      <br />
      Sets a <tt>distinct</tt> clause on the query.
    </p>

<pre>
// select distinct 'first_name' from customers
Knex('customers')
  .distinct('first_name', 'last_name')
  .select()
</pre>

    <p id="Builder-join">
      <b class="header">join</b><code>.join(~mixed~)</code>
      <br />
      The <tt>join</tt> builder can be used several different ways

<pre>
// select distinct 'name' FROM customers WHERE `order_date` > NOW()
Knex('customers')
  .where('order_date', '>', Knex.raw('NOW()'))
  .distinct()
  .select('id', 'name')
</pre>

<pre>
// select distinct 'name' FROM customers WHERE `order_date` > NOW()
Knex('customers')
  .where('order_date', '>', Knex.raw('NOW()'))
  .distinct()
  .select('id', 'name')
</pre>      
      
    </p>

    <p id="Builder-groupBy">
      <b class="header">groupBy</b><code>.groupBy(*names)</code>
      <br />
      Adds a <tt>group by</tt> clause to the query.
    </p>

    <p id="Builder-orderBy">
      <b class="header">orderBy</b><code>.orderBy(column, [direction])</code>
      <br />
      Adds an <tt>order by</tt> clause to the query.
    </p>

    <p id="Builder-having">
      <b class="header">having</b><code>.having(column, operator, value)</code>
      <br />
      Adds a <tt>having</tt> clause to the query.

<pre>
Knex('users')
  .groupBy('count')
  .orderBy('name', 'desc')
  .having('count', '>', 100)
  .select()
  
</pre>
    </p>

    <p id="Builder-offset">
      <b class="header">offset</b><code>.offset(value)</code>
      <br />
      Adds an <tt>offset</tt> clause to the query.
    </p>

    <p id="Builder-limit">
      <b class="header">limit</b><code>.limit(value)</code>
      <br />
      Adds a <tt>limit</tt> clause to the query.
    </p>

<pre>
Knex('users')
  .limit(10)
  .offset(30)
  .select()  
</pre>

    <p id="Builder-insert">
      <b class="header">insert</b><code>.insert(data)</code>
      <br />
      Creates an <tt>insert</tt> query, taking either a hash of properties to be inserted into the row, or
      an array of inserts, to be executed as a single insert command.
    </p>

<pre>
  // generates: "insert into `books`
  Knex('books').insert({title: 'Slaughterhouse Five'})
  
  // generates "select * from `books`;"
  Knex('books')
    .insert([{title: 'Great Gatsby'}, {title: ''}])
    
</pre>


    <p id="Builder-update">
      <b class="header">update</b><code>.update(data)</code>
      <br />
      Creates an <tt>update</tt> query, taking either a hash of properties to be updated into the row, or
      an array of updates, to be executed as a single update command.
    </p>

<pre>
Knex('books').update({
  title: '',
  author: '',
  year: 2014
})
</pre>

    <p id="Builder-del">
      <b class="header">del / delete</b><code>.del()</code>
      <br />
      Aliased to <tt>del</tt> as <tt>delete</tt> is a reserved word in javascript, this method deletes
      one or more rows, based on other conditions specified in the query.
    </p>

<pre>
Knex('accounts')
  .where('activated', false)
  .del()
</pre>

    <p id="Builder-count">
      <b class="header">count</b><code>.count(column)</code>
      <br />
      Performs a count on the specified column.
    </p>

    <p id="Builder-min">
      <b class="header">min</b><code>.min(column)</code>
      <br />
      Gets the minimum value for the specified column.
    </p>

    <p id="Builder-max">
      <b class="header">max</b><code>.max(column)</code>
      <br />
      Gets the maximum value for the specified column.
    </p>

    <p id="Builder-sum">
      <b class="header">sum</b><code>.sum(column)</code>
      <br />
      Retrieve the sum of the values of a given column.
    </p>

    <p id="Builder-increment">
      <b class="header">increment</b><code>.increment(column, value)</code>
      <br />
      Increments a column's value by the specified amount.
    </p>

    <p id="Builder-decrement">
      <b class="header">decrement</b><code>.decrement(column, value)</code>
      <br />
      Decrements a column's value by the specified amount.
    </p>

    <p id="Builder-increment">
      <b class="header">increment</b><code>.increment(column, value)</code>
      <br />
      Increments a column's value by the specified amount.
    </p>

    <p id="Builder-truncate">
      <b class="header">truncate</b><code>.truncate()</code>
      <br />
      Truncates the current table.
    </p>

    <p id="Builder-debug">
      <b class="header">debug</b><code>.debug()</code>
      <br />
      Turns on debugging for the current query chain.
    </p>

    <h2 id="Transaction">Knex.Transaction</h2>

    <p>
      Transactions are handled by passing a handler function into <tt>Knex.Transaction</tt>.
      The handler function accepts a single argument, the promise for committing or rolling back
      the transaction. This argument is then passed into any queries which are involved in the current
      transcaction, working by explicitly passing the .
    </p>

<pre>
Knex.Transaction(function(t) {
  
  Knex('books')
    .transacting(t)
    .insert({name: 'Old Books'})
    .then(function(row) {
      
      return Q.all(_.map([
        {title: 'Canterbury Tales'},
        {title: 'Moby Dick'},
        {title: 'Hamlet'}
      ], function(info) {

        info.row_id = row.id;

        // Some validation could take place here.
        return Knex('book').transacting(t).insert(info);
      
      }));

    })
    .then(t.commit, t.rollback);

}).then(function() {
  console.log('3 new books saved.');
}, function() {
  console.log('Error saving the books.');
});
</pre>
    
    <h2 id="Schema">Knex.Schema</h2>

    <p id="Schema-createTable">
      <b class="header">createTable</b><code>Knex.Schema.createTable(tableName, callback)</code>
      <br />
      Creates a new table on the database, with a callback function to modify the table's 
      structure, using the <a href="#Schema-Building">schema-building</a> commands.
    </p>

<pre>
Knex.Schema.create('users', function (table) {
  table.string('name');
  table.timestamps();
}).then(function () {
  console.log('Users Table is Created!');
});
</pre>

    <p id="Schema-dropTable">
      <b class="header">dropTable</b><code>Knex.Schema.dropTable(tableName)</code>
      <br />
      Drops a table, specified by <tt>tableName</tt>.
    </p>

    <p id="Schema-dropTableIfExists">
      <b class="header">dropTableIfExists</b><code>Knex.Schema.dropTableIfExists(tableName)</code>
      <br />
      Drops a table conditionally if the table exists, specified by <tt>tableName</tt>.
    </p>

    <p id="Schema-table">
      <b class="header">table</b><code>Knex.Schema.table(tableName, callback)</code>
      <br />
      Chooses a database table, and then modifies the table, using the <a href="#Schema-Building">Schema Building</a>
      functions inside of the callback.
    </p>

<pre>
Knex.Schema.table('users', function (table) {
  table.dropColumn('name');
  table.string('first_name');
  table.string('last_name');
}).then(function () {
  console.log('Users Table is Updated!');
});
</pre>

    <p id="Schema-connection">
      <b class="header">connection</b><code>Knex.Schema.connection()</code>
      <br />
      Optional method to explicitly specifiy the 
    </p>

    <h3 id="Schema-Building">Schema Building:</h3>

    <p id="Schema-dropColumn">
      <b class="header">dropColumn</b><code>table.dropColumn(name)</code>
      <br />
      Drops a column.
    </p>

    <p id="Schema-dropColumns">
      <b class="header">dropColumns</b><code>table.dropColumns(*columns)</code>
      <br />
      Takes a variable number of column names, and drops them.
    </p>

    <p id="Schema-increments">
      <b class="header">increments</b><code>table.increments(name)</code>
      <br />
      Adds an auto incrementing column. This will be used as the primary key for the column.
    </p>

    <p id="Schema-integer">
      <b class="header">integer</b><code>table.integer(name)</code>
      <br />
      Adds an integer column.
    </p>

    <p id="Schema-text">
      <b class="header">text</b><code>table.text(name)</code>
      <br />
      Adds a text column.
    </p>
    
    <p id="Schema-string">
      <b class="header">string</b><code>table.string(name)</code>
      <br />
      Adds a string column.
    </p>
    
    <p id="Schema-float">
      <b class="header">float</b><code>table.float(column, [precision], [scale])</code>
      <br />
      Adds a float column, with optional precision and scale.
    </p>
    
    <p id="Schema-decimal">
      <b class="header">decimal</b><code>table.decimal(column, [precision], [scale])</code>
      <br />
      Adds a decimal column, with optional precision and scale.
    </p>
    
    <p id="Schema-boolean">
      <b class="header">boolean</b><code>table.boolean(name)</code>
      <br />
      Adds a boolean column.
    </p>
    
    <p id="Schema-date">
      <b class="header">date</b><code>table.date(name)</code>
      <br />
      Adds a date column.
    </p>
    
    <p id="Schema-dateTime">
      <b class="header">dateTime</b><code>table.dateTime(name)</code>
      <br />
      Adds a dateTime column.
    </p>
    
    <p id="Schema-time">
      <b class="header">time</b><code>table.time(name)</code>
      <br />
      Adds a time column.
    </p>
    
    <p id="Schema-timestamp">
      <b class="header">timestamp</b><code>table.timestamp(name)</code>
      <br />
      Adds a timestamp column.
    </p>
    
    <p id="Schema-binary">
      <b class="header">binary</b><code>table.binary(name)</code>
      <br />
      Adds a binary column.
    </p>
    
    <p id="Schema-enum">
      <b class="header">enum / enu</b><code>table.enu(col, values)</code>
      <br />
      Adds a enum column, (aliased to <tt>enu</tt>, as enum is a reserved word in javascript).
    </p>

    <h3 id="Chainable">Chainable Methods:</h3>

    <p>
      The following three methods may be chained on the schema building methods, as modifiers to the column.
    </p>

    <p id="Chainable-defaultTo">
      <b class="header">defaultTo</b><code>.defaultTo(value)</code>
      <br />
      Sets the default value for the column on an insert.
    </p>

    <p id="Chainable-unsigned">
      <b class="header">unsigned</b><code>.unsigned()</code>
      <br />
      Specifies an integer as unsigned. No-op if this is chained off of a non-integer field.
    </p>

    <p id="Chainable-nullable">
      <b class="header">nullable</b><code>.nullable()</code>
      <br />
      Allows a field to be nullable. No-op if chained off of a non-nullable field.
    </p>

    <p id="Chainable-nullable">
      <b class="header">nullable</b><code>.nullable()</code>
      <br />
      Allows a field to be nullable. No-op if chained off of a non-nullable field.
    </p>

    <p id="Chainable-primary">
      <b class="header">primary</b><code>.primary()</code>
      <br />
      Sets the field as the primary key for the table.
    </p>

<pre>
Knex.createTable('accounts', function() {
  t.increments().primary();
  t.string('email').unique();
});
</pre>

    <h2 id="Knex-client">Knex.client</h2>

    <h2 id="faq">F.A.Q.</h2>

    <p id="faq-debug">
      <b class="header">How do I debug?</b><br />
      If you pass <tt>{debug: true}</tt> as one of the options in your initialize settings, you can see
      all of the query calls being made. Sometimes you need to dive a bit further into
      the various calls and see what all is going on behind the scenes. I'd recommend 
      <a href="https://github.com/dannycoates/node-inspector">node-inspector</a>, which allows you to debug
      code with <tt>debugger</tt> statements like you would in the browser.
    </p>

    <p id="faq-tests">
      <b class="header">How do I run the test suite?</b><br />
      If you pass <tt>{debug: true}</tt> as one of the options in your initialize settings, you can see
      all of the query calls being made. Sometimes you need to dive a bit further into
      the various calls and see what all is going on behind the scenes. I'd recommend 
      <a href="https://github.com/dannycoates/node-inspector">node-inspector</a>, which allows you to debug
      code with <tt>debugger</tt> statements like you would in the browser.
    </p>

    <p id="faq-nonode">
      <b class="header">Can I use Knex outside of Node.js</b><br />
      While there isn't a client adapter yet, it should be possible to run
      it could be adapted to work with other javascript environments supporting a <tt>sqlite3</tt> 
      database, by providing a custom <a href="http://knexjs.org/#Adapters">Knex adapter</a>.
    </p>


    <h2 id="changelog">Change Log</h2>

    <p>
      <b class="header">0.1.0</b> &mdash; <small><i>TBD</i></small><br />
      Initial Knex release.
    </p>

  </div>
  <script src="docs/public/scripts/ga.js" type="text/javascript" charset="utf-8"></script>
</body>
</html>
